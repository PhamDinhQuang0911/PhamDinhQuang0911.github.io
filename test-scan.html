<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demo Scan ·∫¢nh - To√°n th·∫ßy Choang</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        .loading { pointer-events: none; opacity: 0.6; }
        canvas { max-width: 100%; height: auto; border: 1px solid #ccc; border-radius: 8px; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4 flex flex-col items-center">

    <div class="max-w-md w-full bg-white rounded-2xl shadow-xl p-6">
        <h1 class="text-xl font-bold text-gray-800 mb-4 text-center">üì∏ Test T√≠nh NƒÉng Scan</h1>
        
        <div id="status" class="mb-4 text-center text-sm font-bold text-orange-500">
            <i class="fa-solid fa-spinner fa-spin"></i> ƒêang t·∫£i th∆∞ vi·ªán x·ª≠ l√Ω ·∫£nh...
        </div>

        <div class="mb-6">
            <label class="block w-full p-4 border-2 border-dashed border-blue-300 rounded-xl bg-blue-50 text-blue-600 font-bold text-center cursor-pointer hover:bg-blue-100 transition-all">
                <i class="fa-solid fa-camera text-2xl mb-2"></i><br>
                Ch·ª•p ·∫£nh b√†i l√†m
                <input type="file" id="fileInput" accept="image/*" class="hidden" disabled>
            </label>
        </div>

        <div class="space-y-4 hidden" id="resultArea">
            <div>
                <p class="text-xs font-bold text-gray-500 mb-1">1. ·∫¢nh g·ªëc:</p>
                <img id="imageSrc" class="w-full rounded-lg shadow-sm" />
            </div>
            
            <div class="flex justify-center gap-2 my-2">
                <i class="fa-solid fa-arrow-down text-gray-400"></i>
                <span class="text-xs text-gray-400">X·ª≠ l√Ω t·ª± ƒë·ªông</span>
                <i class="fa-solid fa-arrow-down text-gray-400"></i>
            </div>

            <div>
                <p class="text-xs font-bold text-green-600 mb-1">2. K·∫øt qu·∫£ Scan (ƒê√£ n·∫Øn & l√†m r√µ):</p>
                <canvas id="canvasOutput"></canvas>
            </div>
        </div>
    </div>

    <script>
        let cvReady = false;

        function onOpenCvReady() {
            cvReady = true;
            const status = document.getElementById('status');
            status.innerHTML = '<i class="fa-solid fa-check-circle"></i> S·∫µn s√†ng! H√£y ch·ªçn ·∫£nh.';
            status.className = "mb-4 text-center text-sm font-bold text-green-600";
            document.getElementById('fileInput').disabled = false;
        }

        document.getElementById('fileInput').addEventListener('change', (e) => {
            if (!cvReady) return;
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const imgElement = document.getElementById('imageSrc');
                imgElement.src = event.target.result;
                imgElement.onload = () => {
                    document.getElementById('resultArea').classList.remove('hidden');
                    // Ch·ªù ·∫£nh load xong th√¨ x·ª≠ l√Ω
                    setTimeout(processImage, 100);
                };
            };
            reader.readAsDataURL(file);
        });

        function processImage() {
            try {
                // 1. ƒê·ªçc ·∫£nh v√†o OpenCV
                let src = cv.imread('imageSrc');
                let dst = new cv.Mat();
                let gray = new cv.Mat();
                let blurred = new cv.Mat();
                let edges = new cv.Mat();

                // 2. Ti·ªÅn x·ª≠ l√Ω: Resize nh·ªè l·∫°i ƒë·ªÉ x·ª≠ l√Ω cho nhanh (n·∫øu ·∫£nh qu√° to)
                let dsize = new cv.Size(0, 0);
                // Gi·ªØ nguy√™n t·ªâ l·ªá, ch·ªâ resize n·∫øu chi·ªÅu r·ªông > 1000px
                let scale = 1;
                if(src.cols > 1000) {
                    scale = 1000 / src.cols;
                    cv.resize(src, src, dsize, scale, scale, cv.INTER_AREA);
                }

                // 3. Chuy·ªÉn x√°m & L√†m m·ªù (ƒê·ªÉ t√¨m c·∫°nh d·ªÖ h∆°n)
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
                cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
                
                // 4. T√¨m c·∫°nh (Canny Edge Detection)
                cv.Canny(blurred, edges, 75, 200);

                // 5. T√¨m ƒë∆∞·ªùng bao (Contours)
                let contours = new cv.MatVector();
                let hierarchy = new cv.Mat();
                cv.findContours(edges, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

                // 6. T√¨m h√¨nh ch·ªØ nh·∫≠t l·ªõn nh·∫•t (Gi·∫£ s·ª≠ l√† t·ªù gi·∫•y)
                let maxArea = 0;
                let maxContourIndex = -1;
                let approx = new cv.Mat();
                let foundRect = null;

                for (let i = 0; i < contours.size(); ++i) {
                    let cnt = contours.get(i);
                    let area = cv.contourArea(cnt);
                    if (area > 5000) { // B·ªè qua nhi·ªÖu nh·ªè
                        let perimeter = cv.arcLength(cnt, true);
                        cv.approxPolyDP(cnt, approx, 0.02 * perimeter, true);
                        // N·∫øu c√≥ 4 g√≥c v√† di·ªán t√≠ch l·ªõn nh·∫•t -> Kh·∫£ nƒÉng cao l√† t·ªù gi·∫•y
                        if (approx.rows === 4 && area > maxArea) {
                            maxArea = area;
                            maxContourIndex = i;
                            foundRect = approx.clone(); // L∆∞u l·∫°i t·ªça ƒë·ªô 4 g√≥c
                        }
                    }
                }

                // 7. N·∫øu t√¨m th·∫•y gi·∫•y -> N·∫Øn th·∫≥ng (Warp)
                if (foundRect) {
                    // S·∫Øp x·∫øp 4 ƒëi·ªÉm g√≥c: [TopLeft, TopRight, BottomRight, BottomLeft]
                    let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, sortPoints(foundRect));
                    
                    // T√≠nh k√≠ch th∆∞·ªõc ·∫£nh ƒë·∫ßu ra (d·ª±a tr√™n chi·ªÅu r·ªông/cao l·ªõn nh·∫•t)
                    // (Logic ƒë∆°n gi·∫£n h√≥a cho demo: l·∫•y k√≠ch th∆∞·ªõc ·∫£nh g·ªëc)
                    let w = src.cols; 
                    let h = src.rows;
                    
                    let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, w, 0, w, h, 0, h]);
                    let M = cv.getPerspectiveTransform(srcTri, dstTri);
                    
                    cv.warpPerspective(src, dst, M, new cv.Size(w, h));
                    
                    // D·ªçn d·∫πp
                    srcTri.delete(); dstTri.delete(); M.delete();
                } else {
                    // Kh√¥ng t√¨m th·∫•y gi·∫•y -> D√πng nguy√™n ·∫£nh g·ªëc
                    dst = src.clone();
                }

                // 8. L√†m ƒë·∫πp ·∫£nh (Scan Effect)
                // Chuy·ªÉn sang x√°m
                if(dst.channels() > 1) cv.cvtColor(dst, dst, cv.COLOR_RGBA2GRAY, 0);
                
                // Adaptive Threshold (Bi·∫øn th√†nh ƒëen tr·∫Øng r√µ n√©t nh∆∞ m√°y photo)
                cv.adaptiveThreshold(dst, dst, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);

                // 9. Hi·ªÉn th·ªã ra Canvas
                cv.imshow('canvasOutput', dst);

                // D·ªçn d·∫πp b·ªô nh·ªõ (C·ª±c k·ª≥ quan tr·ªçng v·ªõi OpenCV.js)
                src.delete(); dst.delete(); gray.delete(); blurred.delete(); edges.delete();
                contours.delete(); hierarchy.delete(); approx.delete(); if(foundRect) foundRect.delete();

            } catch (err) {
                console.error(err);
                alert("L·ªói x·ª≠ l√Ω ·∫£nh: " + err);
            }
        }

        // H√†m ph·ª• tr·ª£: S·∫Øp x·∫øp 4 ƒëi·ªÉm theo th·ª© t·ª± TL, TR, BR, BL
        function sortPoints(mat) {
            // Chuy·ªÉn Mat sang m·∫£ng ph·∫≥ng
            let points = [];
            for(let i=0; i<4; i++) {
                points.push({x: mat.data32S[i*2], y: mat.data32S[i*2+1]});
            }
            
            // S·∫Øp x·∫øp theo t·ªïng (x+y) ƒë·ªÉ t√¨m TopLeft (min) v√† BottomRight (max)
            points.sort((a,b) => (a.x+a.y) - (b.x+b.y));
            let tl = points[0];
            let br = points[3];
            
            // Hai ƒëi·ªÉm c√≤n l·∫°i: ƒëi·ªÉm n√†o c√≥ x l·ªõn h∆°n l√† TR, b√© h∆°n l√† BL
            let others = [points[1], points[2]];
            others.sort((a,b) => a.x - b.x);
            let bl = others[0];
            let tr = others[1];
            
            return [tl.x, tl.y, tr.x, tr.y, br.x, br.y, bl.x, bl.y];
        }
    </script>
</body>
</html>
